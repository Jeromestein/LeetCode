| Category   | Difficulty     | Likes | Dislikes |
| ---------- | -------------- | ----- | -------- |
| algorithms | #Hard (37.14%) | 218   | 17       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #binary-search #sliding-window #sorting #prefix-sum #array 

**Companies**

`Unknown`

You are given an integer array `nums` and two integers `k` and `numOperations`.

You must perform an **operation** `numOperations` times on `nums`, where in each operation you:

- Select an index `i` that was **not** selected in any previous operations.
- Add an integer in the range `[-k, k]` to `nums[i]`.

Return the **maximum** possible frequency of any element in `nums` after performing the **operations**.

**Example 1:**

**Input:** nums = [1,4,5], k = 1, numOperations = 2

**Output:** 2

**Explanation:**

We can achieve a maximum frequency of two by:

- Adding 0 to `nums[1]`, after which `nums` becomes `[1, 4, 5]`.
- Adding -1 to `nums[2]`, after which `nums` becomes `[1, 4, 4]`.

**Example 2:**

**Input:** nums = [5,11,20,20], k = 5, numOperations = 1

**Output:** 2

**Explanation:**

We can achieve a maximum frequency of two by:

- Adding 0 to `nums[1]`.

**Constraints:**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `0 <= k <= 109`
- `0 <= numOperations <= nums.length`

---

[Submissions](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/submissions/?source=vscode "https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/solutions/?source=vscode "https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/solutions/?source=vscode")


```python

class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        ans = 0
        num_count = defaultdict(int)
        modes = set()

        def add_mode(value):
            modes.add(value)
            if value - k >= nums[0]:
                modes.add(value - k)
            if value + k <= nums[-1]:
                modes.add(value + k)

        last_num_index = 0
        for i in range(len(nums)):
            if nums[i] != nums[last_num_index]:
                num_count[nums[last_num_index]] = i - last_num_index
                ans = max(ans, i - last_num_index)
                add_mode(nums[last_num_index])
                last_num_index = i

        num_count[nums[last_num_index]] = len(nums) - last_num_index
        ans = max(ans, len(nums) - last_num_index)
        add_mode(nums[last_num_index])

        for mode in sorted(modes):
            l = bisect.bisect_left(nums, mode - k)
            r = bisect.bisect_right(nums, mode + k) - 1
            if mode in num_count:
                temp_ans = min(r - l + 1, num_count[mode] + numOperations)
            else:
                temp_ans = min(r - l + 1, numOperations)
            ans = max(ans, temp_ans)

        return ans

```

#### Complexity Analysis

Let n be the length of nums.

- Time complexity: O(nlogn).
    
    Sorting takes O(nlogn) time, preprocessing takes O(n), and enumerating the mode also takes O(nlogn). Therefore, the overall time complexity is O(nlogn).
    
- Space complexity: O(n).