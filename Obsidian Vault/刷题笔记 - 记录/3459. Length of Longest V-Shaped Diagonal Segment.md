

| Category   | Difficulty     | Likes | Dislikes |
| ---------- | -------------- | ----- | -------- |
| algorithms | #Hard (33.62%) | 322   | 56       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #matrix #dfs #cache

**Companies**

`Unknown`

You are given a 2D integer matrix `grid` of size `n x m`, where each element is either `0`, `1`, or `2`.

A **V-shaped diagonal segment** is defined as:

- The segment starts with `1`.
- The subsequent elements follow this infinite sequence: `2, 0, 2, 0, ...`.
- The segment:
    - Starts **along** a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).
    - Continues the **sequence** in the same diagonal direction.
    - Makes **at most one clockwise 90-degree** **turn** to another diagonal direction while **maintaining** the sequence.

![](https://assets.leetcode.com/uploads/2025/01/11/length_of_longest3.jpg)

Return the **length** of the **longest** **V-shaped diagonal segment**. If no valid segment _exists_, return 0.

**Example 1:**

**Input:** grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]

**Output:** 5

**Explanation:**

![](https://assets.leetcode.com/uploads/2024/12/09/matrix_1-2.jpg)

The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: `(0,2) → (1,3) → (2,4)`, takes a **90-degree clockwise turn** at `(2,4)`, and continues as `(3,3) → (4,2)`.

**Example 2:**

**Input:** grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]

**Output:** 4

**Explanation:**

**![](https://assets.leetcode.com/uploads/2024/12/09/matrix_2.jpg)**

The longest V-shaped diagonal segment has a length of 4 and follows these coordinates: `(2,3) → (3,2)`, takes a **90-degree clockwise turn** at `(3,2)`, and continues as `(2,1) → (1,0)`.

**Example 3:**

**Input:** grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]

**Output:** 5

**Explanation:**

**![](https://assets.leetcode.com/uploads/2024/12/09/matrix_3.jpg)**

The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: `(0,0) → (1,1) → (2,2) → (3,3) → (4,4)`.

**Example 4:**

**Input:** grid = [[1]]

**Output:** 1

**Explanation:**

The longest V-shaped diagonal segment has a length of 1 and follows these coordinates: `(0,0)`.

**Constraints:**

- `n == grid.length`
- `m == grid[i].length`
- `1 <= n, m <= 500`
- `grid[i][j]` is either `0`, `1` or `2`.

---

[Submissions](https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/submissions/?source=vscode "https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/solutions/?source=vscode "https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/solutions/?source=vscode")

```python

from typing import List
from functools import lru_cache

class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        # SE, SW, NW, NE (clockwise order)
        DIRS = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
        m, n = len(grid), len(grid[0])

        def in_bounds(x: int, y: int) -> bool:
            return 0 <= x < m and 0 <= y < n

        @cache
        def dfs(x: int, y: int, dir_idx: int, can_turn: bool, target: int) -> int:
            """
            Return the max number of further steps starting from (x,y),
            moving one step first (must match `target`), then optionally
            continuing straight or making at most one clockwise 90° turn.
            """
            nx, ny = x + DIRS[dir_idx][0], y + DIRS[dir_idx][1]
            # next cell must be inside and equal to `target`
            if not in_bounds(nx, ny) or grid[nx][ny] != target:
                return 0

            # 1) continue straight
            best = dfs(nx, ny, dir_idx, can_turn, 2 - target)  # toggle target: 2<->0

            # 2) optional clockwise turn (only once)
            if can_turn:
                nd = (dir_idx + 1) % 4
                best = max(best, dfs(nx, ny, nd, False, 2 - target))

            return best + 1  # count current step

        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:  # start only from cells with value 1
                    for d in range(4):
                        # start length is 1 (the starting cell), then extend
                        ans = max(ans, 1 + dfs(i, j, d, True, 2))
        return ans

```

#### Complexity Analysis

Let m,n be the number of rows and columns of the given matrix grid.

- Time complexity: O(m⋅n).
    
    There are O(m⋅n) substates in the memoization search, and each state takes O(1) time to compute.
    
- Space complexity: O(mn).
    
    Both the memoization table and the recursion stack require O(m⋅n) space.