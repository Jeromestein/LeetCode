| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (21.11%) | 486   | 89       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #binary-search  #array #sorting 

**Companies**

`Unknown`

You are given an integer array `nums` and two integers `k` and `numOperations`.

You must perform an **operation** `numOperations` times on `nums`, where in each operation you:

- Select an index `i` that was **not** selected in any previous operations.
- Add an integer in the range `[-k, k]` to `nums[i]`.

Return the **maximum** possible frequency of any element in `nums` after performing the **operations**.

**Example 1:**

**Input:** nums = [1,4,5], k = 1, numOperations = 2

**Output:** 2

**Explanation:**

We can achieve a maximum frequency of two by:

- Adding 0 to `nums[1]`. `nums` becomes `[1, 4, 5]`.
- Adding -1 to `nums[2]`. `nums` becomes `[1, 4, 4]`.

**Example 2:**

**Input:** nums = [5,11,20,20], k = 5, numOperations = 1

**Output:** 2

**Explanation:**

We can achieve a maximum frequency of two by:

- Adding 0 to `nums[1]`.

**Constraints:**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`
- `0 <= k <= 105`
- `0 <= numOperations <= nums.length`

---

[Submissions](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/submissions/?source=vscode "https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/solutions/?source=vscode "https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/solutions/?source=vscode")

```python

class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        ans = 0
        num_count = {}
        last_num_index = 0
        for i in range(len(nums)):
            if nums[i] != nums[last_num_index]:
                num_count[nums[last_num_index]] = i - last_num_index
                ans = max(ans, i - last_num_index)
                last_num_index = i

        num_count[nums[last_num_index]] = len(nums) - last_num_index
        ans = max(ans, len(nums) - last_num_index)

        for i in range(nums[0], nums[-1] + 1):
            l = bisect.bisect_left(nums, i - k)
            r = bisect.bisect_right(nums, i + k) - 1
            if i in num_count:
                temp_ans = min(r - l + 1, num_count[i] + numOperations)
            else:
                temp_ans = min(r - l + 1, numOperations)
            ans = max(ans, temp_ans)

        return ans

```

O(max(nlogn,klogn))
O(n)