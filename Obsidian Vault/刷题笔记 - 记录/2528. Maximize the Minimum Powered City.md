| Category   | Difficulty     | Likes | Dislikes |
| ---------- | -------------- | ----- | -------- |
| algorithms | #Hard (33.22%) | 782   | 26       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #prefix-sum #sliding-window #greedy #binary-search #array 

**Companies**

`Unknown`

You are given a **0-indexed** integer array `stations` of length `n`, where `stations[i]` represents the number of power stations in the `ith` city.

Each power station can provide power to every city in a fixed **range**. In other words, if the range is denoted by `r`, then a power station at city `i` can provide power to all cities `j` such that `|i - j| <= r` and `0 <= i, j <= n - 1`.

- Note that `|x|` denotes **absolute** value. For example, `|7 - 5| = 2` and `|3 - 10| = 7`.

The **power** of a city is the total number of power stations it is being provided power from.

The government has sanctioned building `k` more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.

Given the two integers `r` and `k`, return _the **maximum possible minimum power** of a city, if the additional power stations are built optimally._

**Note** that you can build the `k` power stations in multiple cities.

**Example 1:**

```
Input: stations = [1,2,4,5,0], r = 1, k = 2
Output: 5
Explanation: 
One of the optimal ways is to install both the power stations at city 1. 
So stations will become [1,4,4,5,0].
- City 0 is provided by 1 + 4 = 5 power stations.
- City 1 is provided by 1 + 4 + 4 = 9 power stations.
- City 2 is provided by 4 + 4 + 5 = 13 power stations.
- City 3 is provided by 5 + 4 = 9 power stations.
- City 4 is provided by 5 + 0 = 5 power stations.
So the minimum power of a city is 5.
Since it is not possible to obtain a larger power, we return 5.
```

**Example 2:**

```
Input: stations = [4,4,4,4], r = 0, k = 3
Output: 4
Explanation: 
It can be proved that we cannot make the minimum power of a city greater than 4.
```

**Constraints:**

- `n == stations.length`
- `1 <= n <= 105`
- `0 <= stations[i] <= 105`
- `0 <= r <= n - 1`
- `0 <= k <= 109`

---

[Submissions](https://leetcode.com/problems/maximize-the-minimum-powered-city/submissions/?source=vscode "https://leetcode.com/problems/maximize-the-minimum-powered-city/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/?source=vscode "https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/?source=vscode")


```python

class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)
        cnt = [0] * (n + 1)

        # Build prefix difference array to compute power coverage
        # Each power station at i affects cities in range [i - r, i + r]
        for i in range(n):
            left = max(0, i - r)
            right = min(n, i + r + 1)
            cnt[left] += stations[i]
            cnt[right] -= stations[i]

        # Check if it's possible to make every city's power >= val
        def check(val: int) -> bool:
            # Copy base power difference array
            diff = cnt.copy()
            total = 0           # Current cumulative power
            remaining = k       # Remaining stations we can add

            # Traverse each city from left to right
            for i in range(n):
                total += diff[i]  # Current city’s total power after all previous adjustments

                if total < val:
                    # Need to add extra power stations
                    add = val - total
                    if remaining < add:
                        # Not enough stations to reach required power
                        return False
                    remaining -= add
                    end = min(n, i + 2 * r + 1)
                    # Apply difference update — this added power affects future cities
                    diff[end] -= add
                    total += add  # Update current total power
            return True

        # Binary search for the maximum minimal power possible
        lo, hi = min(stations), sum(stations) + k
        res = 0
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                res = mid      # It's possible to achieve at least mid power
                lo = mid + 1   # Try higher
            else:
                hi = mid - 1   # Too high, try lower
        return res

```

#### Complexity Analysis

Let n be the length of the array stations, D=sum(stations)+k.

- Time complexity: O(nlogD).
    
    Computing the difference array takes O(n) time. The binary search runs in O(logD) iterations, and each iteration takes O(n) time, resulting in a total complexity of O(nlogD).
    
- Space complexity: O(n).
    
    The space required for calculating the difference array is O(n).