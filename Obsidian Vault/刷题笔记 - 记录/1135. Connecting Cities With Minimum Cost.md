| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (62.67%) | 1162  | 60       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #union-find #graph #minimum-spanning-tree

**Companies**

`Unknown`

There are `n` cities labeled from `1` to `n`. You are given the integer `n` and an array `connections` where `connections[i] = [xi, yi, costi]` indicates that the cost of connecting city `xi` and city `yi` (bidirectional connection) is `costi`.

Return _the minimum **cost** to connect all the_ `n` _cities such that there is at least one path between each pair of cities_. If it is impossible to connect all the `n` cities, return `-1`,

The **cost** is the sum of the connections' costs used.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/04/20/1314_ex2.png)

```
Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]
Output: 6
Explanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/04/20/1314_ex1.png)

```
Input: n = 4, connections = [[1,2,3],[3,4,4]]
Output: -1
Explanation: There is no way to connect all cities even if all edges are used.
```

**Constraints:**

- `1 <= n <= 104`
- `1 <= connections.length <= 104`
- `connections[i].length == 3`
- `1 <= xi, yi <= n`
- `xi != yi`
- `0 <= costi <= 105`

---

[Submissions](https://leetcode.com/problems/connecting-cities-with-minimum-cost/submissions/?source=vscode "https://leetcode.com/problems/connecting-cities-with-minimum-cost/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/connecting-cities-with-minimum-cost/solutions/?source=vscode "https://leetcode.com/problems/connecting-cities-with-minimum-cost/solutions/?source=vscode")

- Algorithm: **Kruskal’s MST**
    
- Time Complexity: O(E log E)
    
- Space Complexity: O(N)
    
- Data Structure: **Union-Find (Disjoint Set)**
```python


class Solution:
    def minimumCost(self, n: int, connections: List[List[int]]) -> int:
        # Step 1. Sort edges by cost (ascending)
        connections.sort(key=lambda x: x[2])

        # Step 2. Initialize Union-Find (Disjoint Set Union)
        parent = [i for i in range(n + 1)]  # cities are 1-indexed
        rank = [0] * (n + 1)

        # Find with path compression
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        # Union by rank
        def union(x, y):
            rootX, rootY = find(x), find(y)
            if rootX == rootY:
                return False  # already connected
            if rank[rootX] < rank[rootY]:
                parent[rootX] = rootY
            elif rank[rootX] > rank[rootY]:
                parent[rootY] = rootX
            else:
                parent[rootY] = rootX
                rank[rootX] += 1
            return True

        # Step 3. Kruskal’s algorithm
        total_cost = 0
        edges_used = 0

        for u, v, cost in connections:
            if union(u, v):           # connect two components
                total_cost += cost
                edges_used += 1
                if edges_used == n - 1:  # all cities connected
                    return total_cost

        # Step 4. If not all cities are connected, return -1
        return -1
```

O(NlogN)
O(N)