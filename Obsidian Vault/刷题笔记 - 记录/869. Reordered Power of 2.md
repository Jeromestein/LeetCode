
| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (62.14%) | 2404  | 473      |

**Tags**

[`depth-first-search`](https://leetcode.com/tag/depth-first-search?source=vscode "https://leetcode.com/tag/depth-first-search?source=vscode") | [`union-find`](https://leetcode.com/tag/union-find?source=vscode "https://leetcode.com/tag/union-find?source=vscode") | [`graph`](https://leetcode.com/tag/graph?source=vscode "https://leetcode.com/tag/graph?source=vscode") #enumeration 

**Companies**

`Unknown`

You are given an integer `n`. We reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return `true` _if and only if we can do this so that the resulting number is a power of two_.

**Example 1:**

```
Input: n = 1
Output: true
```

**Example 2:**

```
Input: n = 10
Output: false
```

**Constraints:**

- `1 <= n <= 109`

---

[Submissions](https://leetcode.com/problems/reordered-power-of-2/submissions/?source=vscode "https://leetcode.com/problems/reordered-power-of-2/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/reordered-power-of-2/solutions/?source=vscode "https://leetcode.com/problems/reordered-power-of-2/solutions/?source=vscode")


```python

class Solution:
    def reorderedPowerOf2(self, N: int) -> bool:
        # Return a canonical "signature" of a number's digits
        # e.g. 128 -> ('1','2','8'), 281 -> ('1','2','8')
        def digit_signature(x: int) -> tuple[str, ...]:
            return tuple(sorted(str(x)))

        target_sig = digit_signature(N)
        target_len = len(str(N))

        # Only check powers of two that have the same number of digits
        # 2^0..2^30 covers up to 1,073,741,824 (> 1e9), enough for constraints
        for b in range(31):
            val = 1 << b
            if len(str(val)) != target_len:
                continue
            if digit_signature(val) == target_sig:
                return True

        return False

```


## **Complexity Analysis**

- Time Complexity: O(log^{2}N). There are logN different candidate powers of 2, and each comparison has O(logN) time complexity.
    
- Space Complexity: O(logN).