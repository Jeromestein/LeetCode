
| Category   | Difficulty     | Likes | Dislikes |
| ---------- | -------------- | ----- | -------- |
| algorithms | #Hard (35.26%) | 857   | 50       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #greedy #hash-table #sorting 

**Companies**

`Unknown`

You have two fruit baskets containing `n` fruits each. You are given two **0-indexed** integer arrays `basket1` and `basket2` representing the cost of fruit in each basket. You want to make both baskets **equal**. To do so, you can use the following operation as many times as you want:

- Choose two indices `i` and `j`, and swap the `ith` fruit of `basket1` with the `jth` fruit of `basket2`.
- The cost of the swap is `min(basket1[i], basket2[j])`.

Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.

Return _the minimum cost to make both the baskets equal or_ `-1` _if impossible._

**Example 1:**

```
Input: basket1 = [4,2,2,2], basket2 = [1,4,1,2]
Output: 1
Explanation: Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal.
```

**Example 2:**

```
Input: basket1 = [2,3,4,1], basket2 = [3,2,5,1]
Output: -1
Explanation: It can be shown that it is impossible to make both the baskets equal.
```

**Constraints:**

- `basket1.length == basket2.length`
- `1 <= basket1.length <= 105`
- `1 <= basket1[i], basket2[i] <= 109`

---

[Submissions](https://leetcode.com/problems/rearranging-fruits/submissions/?source=vscode "https://leetcode.com/problems/rearranging-fruits/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/rearranging-fruits/solutions/?source=vscode "https://leetcode.com/problems/rearranging-fruits/solutions/?source=vscode")

```python

from collections import Counter
from typing import List

class Solution:
    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        """
        Make the two baskets have the same multiset by swapping elements.
        Each mismatch can be fixed either directly (cost = value) or indirectly
        via the global minimum element (cost = 2 * global_min). Return the minimum total cost.
        If it's impossible (some value has odd total count), return -1.
        """
        imbalance = Counter()           # difference in counts: basket1 minus basket2
        global_min = float("inf")       # smallest element seen across both baskets

        # Count items in first basket and track global minimum
        for val in basket1:
            imbalance[val] += 1
            if val < global_min:
                global_min = val

        # Subtract counts from second basket and update global minimum
        for val in basket2:
            imbalance[val] -= 1
            if val < global_min:
                global_min = val

        # Build list of surplus values that need to be swapped (only one side's excess)
        surplus = []
        for value, diff in imbalance.items():
            if diff % 2 != 0:
                # If any value has odd total imbalance, impossible to pair
                return -1
            need = abs(diff) // 2
            if need:
                surplus.extend([value] * need)

        if not surplus:
            # Already balanced
            return 0

        surplus.sort()  # sort to greedily pick smallest values to fix first

        half = len(surplus) // 2  # each actual swap fixes two surplus entries
        total_cost = 0
        for x in surplus[:half]:
            # For each required move, choose the cheaper: direct swap (x) or via global min (2*global_min)
            total_cost += min(x, 2 * global_min)

        return total_cost

```

#### Complexity Analysis

Let n be the length of the arrays basket1 and basket2.

- Time complexity: O(nlogn).
    
    Sorting the merge array requires O(nlogn) time.
    
- Space complexity: O(n).
    
    The hash tables and the merge array each require O(n) space.