| Category   | Difficulty     | Likes | Dislikes |
| ---------- | -------------- | ----- | -------- |
| algorithms | #Easy (88.40%) | 453   | 20       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #array #bit-minipulation #set 

**Companies**

`Unknown`

In the town of Digitville, there was a list of numbers called `nums` containing integers from `0` to `n - 1`. Each number was supposed to appear **exactly once** in the list, however, **two** mischievous numbers sneaked in an _additional time_, making the list longer than usual.

As the town detective, your task is to find these two sneaky numbers. Return an array of size **two** containing the two numbers (in _any order_), so peace can return to Digitville.

**Example 1:**

**Input:** nums = [0,1,1,0]

**Output:** [0,1]

**Explanation:**

The numbers 0 and 1 each appear twice in the array.

**Example 2:**

**Input:** nums = [0,3,2,1,3,2]

**Output:** [2,3]

**Explanation:**

The numbers 2 and 3 each appear twice in the array.

**Example 3:**

**Input:** nums = [7,1,5,4,3,4,6,0,9,5,8,2]

**Output:** [4,5]

**Explanation:**

The numbers 4 and 5 each appear twice in the array.

**Constraints:**

- `2 <= n <= 100`
- `nums.length == n + 2`
- `0 <= nums[i] < n`
- The input is generated such that `nums` contains **exactly** two repeated elements.

---

[Submissions](https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/submissions/?source=vscode "https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/solutions/?source=vscode "https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/solutions/?source=vscode")


```python

class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        # There are (n + 2) numbers in nums, where 0..n should appear once,
        # but two of them are duplicated (the "sneaky numbers").
        n = len(nums) - 2

        # Step 1: XOR all numbers in nums to get y
        y = 0
        for x in nums:
            y ^= x  # XOR all elements in the input array

        # Step 2: XOR all numbers from 0 to n
        for i in range(n):
            y ^= i  # XOR expected unique range [0..n-1]

        # After these two loops:
        # y = duplicate1 ^ duplicate2
        # because all other numbers (that appear once) cancel out (a ^ a = 0)

        # Step 3: Find the rightmost set bit (lowest differing bit)
        lowBit = y & -y
        # This bit distinguishes the two sneaky numbers (they differ here)

        x1 = x2 = 0

        # Step 4: Divide nums into two groups based on lowBit
        # One group has this bit = 1, the other has it = 0
        # Then XOR within each group separately.
        for x in nums:
            if x & lowBit:
                x1 ^= x
            else:
                x2 ^= x

        # Step 5: Do the same partition for 0..n (the normal range)
        # to remove all single occurrences (cancel them out)
        for i in range(n):
            if i & lowBit:
                x1 ^= i
            else:
                x2 ^= i

        # Step 6: Now x1 and x2 are the two duplicate (sneaky) numbers
        return [x1, x2]

```

O(n)
O(1)

```python

class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        # return in any order
        pre_idx=set()
        res=list()

        for n in nums:
            if n not in pre_idx:
                pre_idx.add(n)
            else:
                res.append(n)

        return res


```

O(n)
O(n)