| Category   | Difficulty    | Likes | Dislikes |
| ---------- | ------------- | ----- | -------- |
| algorithms | Hard (45.29%) | 1020  | 105      |

**Tags**

[`bit-manipulation`](https://leetcode.com/tag/bit-manipulation?source=vscode "https://leetcode.com/tag/bit-manipulation?source=vscode") | [`depth-first-search`](https://leetcode.com/tag/depth-first-search?source=vscode "https://leetcode.com/tag/depth-first-search?source=vscode") #array #intervals

**Companies**

`Unknown`

You are given a 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents all the integers from `starti` to `endi` inclusively.

A **containing set** is an array `nums` where each interval from `intervals` has **at least two** integers in `nums`.

- For example, if `intervals = [[1,3], [3,7], [8,9]]`, then `[1,2,4,7,8,9]` and `[2,3,4,8,9]` are **containing sets**.

Return _the minimum possible size of a containing set_.

**Example 1:**

```
Input: intervals = [[1,3],[3,7],[8,9]]
Output: 5
Explanation: let nums = [2, 3, 4, 8, 9].
It can be shown that there cannot be any containing array of size 4.
```

**Example 2:**

```
Input: intervals = [[1,3],[1,4],[2,5],[3,5]]
Output: 3
Explanation: let nums = [2, 3, 4].
It can be shown that there cannot be any containing array of size 2.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3],[2,4],[4,5]]
Output: 5
Explanation: let nums = [1, 2, 3, 4, 5].
It can be shown that there cannot be any containing array of size 4.
```

**Constraints:**

- `1 <= intervals.length <= 3000`
- `intervals[i].length == 2`
- `0 <= starti < endi <= 108`

---

[Submissions](https://leetcode.com/problems/set-intersection-size-at-least-two/submissions/?source=vscode "https://leetcode.com/problems/set-intersection-size-at-least-two/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/set-intersection-size-at-least-two/solutions/?source=vscode "https://leetcode.com/problems/set-intersection-size-at-least-two/solutions/?source=vscode")

```python

class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        # Sort intervals by:
        #   1. Right endpoint ascending
        #   2. Left endpoint descending (to handle equal right endpoints)
        intervals.sort(key=lambda x: (x[1], -x[0]))

        count = 0  # total number of selected points
        second_last = -1  # second largest point in the chosen set
        last = -1         # largest point in the chosen set

        for left, right in intervals:

            # Case 1:
            # No selected points lie in the interval [left, right]
            # Because even the largest point ('last') is < left
            # → we must add TWO points (right-1, right)
            if left > last:
                second_last = right - 1
                last = right
                count += 2

            # Case 2:
            # Exactly one selected point lies in [left, right]
            # This happens if:
            #   second_last < left <= last
            # → we must add ONE point (right)
            elif left > second_last:
                second_last = last
                last = right
                count += 1

            # Case 3:
            # Already have two points in the interval, do nothing.
            else:
                continue

        return count

```
O(nlogn)
O(logn)
