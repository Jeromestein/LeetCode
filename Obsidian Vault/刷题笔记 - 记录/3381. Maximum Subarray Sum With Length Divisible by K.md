
| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (27.05%) | 508   | 33       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #prefix-sum #array #divide 

**Companies**

`Unknown`

You are given an array of integers `nums` and an integer `k`.

Return the **maximum** sum of a subarray of `nums`, such that the size of the subarray is **divisible** by `k`.

**Example 1:**

**Input:** nums = [1,2], k = 1

**Output:** 3

**Explanation:**

The subarray `[1, 2]` with sum 3 has length equal to 2 which is divisible by 1.

**Example 2:**

**Input:** nums = [-1,-2,-3,-4,-5], k = 4

**Output:** -10

**Explanation:**

The maximum sum subarray is `[-1, -2, -3, -4]` which has length equal to 4 which is divisible by 4.

**Example 3:**

**Input:** nums = [-5,1,2,-3,4], k = 2

**Output:** 4

**Explanation:**

The maximum sum subarray is `[1, 2, -3, 4]` which has length equal to 4 which is divisible by 2.

**Constraints:**

- `1 <= k <= nums.length <= 2 * 105`
- `-109 <= nums[i] <= 109`

---

[Submissions](https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/submissions/?source=vscode "https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/solutions/?source=vscode "https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/solutions/?source=vscode")

```python

class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        prefixSum = 0
        maxSum = -float('inf')

        # kSum[r] will store the **minimum prefix sum** among all prefix indices t
        # such that t % k == r.
        kSum = [float('inf')] * k

        # Trick:
        # Consider prefix index t = -1, with prefix sum P[-1] = 0 (sum of zero elements).
        # For t = -1, we define (-1) % k as k - 1 in Python (since -1 % k == k-1).
        #
        # This corresponds to the "empty prefix" before the array starts.
        # So we set:
        #    kSum[k-1] = 0
        # meaning:
        #    "the minimum prefix sum for remainder (k-1) is 0 at index -1".
        kSum[k - 1] = 0

        # Iterate over all elements as the end index of the subarray
        for i in range(n):
            # Update prefix sum up to index i: P[i] = P[i-1] + nums[i]
            prefixSum += nums[i]

            # We are at index i, with prefix sum P[i].
            # We want a starting prefix index t (meaning subarray starts at t+1)
            # such that:
            #   - The subarray length (i - (t+1) + 1) = i - t is divisible by k.
            #
            # That condition is: (i - t) % k == 0   =>   i % k == t % k.
            #
            # Also, the subarray sum is: P[i] - P[t].
            #
            # So for current i, we need the **minimum** P[t] over all t whose t % k == i % k.
            # We store this minimum in kSum[i % k].
            #
            # Candidate maximum sum if we end at i:
            #   prefixSum - (minimum prefix sum with same remainder)
            maxSum = max(maxSum, prefixSum - kSum[i % k])

            # Now we update kSum[i % k] with the current prefixSum,
            # because index i itself is a candidate "starting prefix" for future subarrays.
            # We take the minimum to always keep the smallest prefix sum for this remainder.
            kSum[i % k] = min(kSum[i % k], prefixSum)

        return maxSum
```
O(n)
O(k)