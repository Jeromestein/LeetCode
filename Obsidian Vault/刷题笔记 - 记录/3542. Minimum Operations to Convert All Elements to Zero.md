| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (23.69%) | 466   | 50       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #array #stack #greedy 

**Companies**

`Unknown`

You are given an array `nums` of size `n`, consisting of **non-negative** integers. Your task is to apply some (possibly zero) operations on the array so that **all** elements become 0.

In one operation, you can select a subarray `[i, j]` (where `0 <= i <= j < n`) and set all occurrences of the **minimum** **non-negative** integer in that subarray to 0.

Return the **minimum** number of operations required to make all elements in the array 0.

**Example 1:**

**Input:** nums = [0,2]

**Output:** 1

**Explanation:**

- Select the subarray `[1,1]` (which is `[2]`), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in `[0,0]`.
- Thus, the minimum number of operations required is 1.

**Example 2:**

**Input:** nums = [3,1,2,1]

**Output:** 3

**Explanation:**

- Select subarray `[1,3]` (which is `[1,2,1]`), where the minimum non-negative integer is 1. Setting all occurrences of 1 to 0 results in `[3,0,2,0]`.
- Select subarray `[2,2]` (which is `[2]`), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in `[3,0,0,0]`.
- Select subarray `[0,0]` (which is `[3]`), where the minimum non-negative integer is 3. Setting all occurrences of 3 to 0 results in `[0,0,0,0]`.
- Thus, the minimum number of operations required is 3.

**Example 3:**

**Input:** nums = [1,2,1,2,1,2]

**Output:** 4

**Explanation:**

- Select subarray `[0,5]` (which is `[1,2,1,2,1,2]`), where the minimum non-negative integer is 1. Setting all occurrences of 1 to 0 results in `[0,2,0,2,0,2]`.
- Select subarray `[1,1]` (which is `[2]`), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in `[0,0,0,2,0,2]`.
- Select subarray `[3,3]` (which is `[2]`), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in `[0,0,0,0,0,2]`.
- Select subarray `[5,5]` (which is `[2]`), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in `[0,0,0,0,0,0]`.
- Thus, the minimum number of operations required is 4.

**Constraints:**

- `1 <= n == nums.length <= 105`
- `0 <= nums[i] <= 105`

---

[Submissions](https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/submissions/?source=vscode "https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/solutions/?source=vscode "https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/solutions/?source=vscode")

```python

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        s = []      # Monotonic increasing stack of *positive* "active layers"
        res = 0     # Number of operations needed

        for a in nums:
            # Maintain a strictly increasing stack:
            # any layer higher than current 'a' can never be the minimum of
            # a future chosen subarray (because 'a' is smaller and appears earlier),
            # so those higher layers are not needed anymore.
            while s and s[-1] > a:
                s.pop()

            # Zeros already represent a "scraped" level; no operation needed.
            if a == 0:
                continue

            # If 'a' equals the top layer, it belongs to the same layer → no new op.
            # If there is no layer yet OR 'a' is strictly higher than the top,
            # we have encountered a *new bottom layer* that will require one operation
            # to be turned to zero somewhere in a subarray.
            if not s or s[-1] < a:
                res += 1     # one more operation for this new layer
                s.append(a)  # track this active layer

        return res

```
O(n)
O(n)