| Category   | Difficulty     | Likes | Dislikes |
| ---------- | -------------- | ----- | -------- |
| algorithms | #Hard (68.82%) | 170   | 33       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #matrix #greedy #sorting 

**Companies**

`Unknown`

Consider a matrix `M` with dimensions `width * height`, such that every cell has value `0` or `1`, and any **square** sub-matrix of `M` of size `sideLength * sideLength` has at most `maxOnes` ones.

Return the maximum possible number of ones that the matrix `M` can have.

**Example 1:**

```
Input: width = 3, height = 3, sideLength = 2, maxOnes = 1
Output: 4
Explanation:
In a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.
The best solution that has 4 ones is:
[1,0,1]
[0,0,0]
[1,0,1]
```

**Example 2:**

```
Input: width = 3, height = 3, sideLength = 2, maxOnes = 2
Output: 6
Explanation:
[1,0,1]
[1,0,1]
[1,0,1]
```

**Constraints:**

- `1 <= width, height <= 100`
- `1 <= sideLength <= width, height`
- `0 <= maxOnes <= sideLength * sideLength`

---

[Submissions](https://leetcode.com/problems/maximum-number-of-ones/submissions/?source=vscode "https://leetcode.com/problems/maximum-number-of-ones/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/maximum-number-of-ones/solutions/?source=vscode "https://leetcode.com/problems/maximum-number-of-ones/solutions/?source=vscode")


```python

class Solution:
    def maximumNumberOfOnes(self, width: int, height: int, sideLength: int, maxOnes: int) -> int:
        # 'count' will store how many times each cell (r, c)
        # in the repeating pattern is covered by a sideLength × sideLength submatrix.
        count = []
        
        # Iterate over every possible position (r, c)
        # inside one pattern tile (of size sideLength × sideLength)
        for r in range(sideLength):
            for c in range(sideLength):
                # The key idea:
                # For a given cell (r, c), we compute how many times
                # this cell appears inside all possible sideLength × sideLength windows
                # when the pattern of size (height × width) is tiled infinitely.

                # Compute how many times the cell contributes vertically and horizontally.
                # (width - c - 1) is how far the column is from the right edge.
                # Dividing by sideLength gives how many complete blocks fit after it,
                # and adding 1 counts the current block.
                # Same logic for the vertical direction.
                #
                # In other words:
                # num = (# of pattern repetitions along x) * (# of repetitions along y)
                #
                # Example:
                # - If width = 8, sideLength = 5, c = 1
                #   → (width - c - 1) // sideLength = 1 → (1 + 1) = 2 columns contribute
                # - So this cell appears twice horizontally across all windows.
                num = (1 + (width - c - 1) // sideLength) * (1 + (height - r - 1) // sideLength)
                
                # Append this cell's appearance count
                count.append(num)
                
        # Sort all cells by their contribution frequency (descending)
        count.sort(reverse=True)
        
        # We can only place 'maxOnes' number of ones in the base pattern.
        # To maximize the total number of ones in all sideLength × sideLength windows,
        # we pick the 'maxOnes' cells that appear the most frequently.
        return sum(count[:maxOnes])

```

#### Complexity Analysis

- Time complexity: O(sideLength^2⋅logsideLength^2)
    
    - The array `count` contains all the cells in the top-left window of size sideLength×sideLength, which takes O(sideLength2) time to fill.
        
    - Sorting an array of size n takes n⋅logn time, thus it takes O(sideLength2⋅logsideLength2) time to sort `count`.
        
- Space complexity: O(sideLength^2)
    
    - The array `count` contains all the cells in the top-left window of size sideLength×sideLength