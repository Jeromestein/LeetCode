
| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (35.34%) | 418   | 305      |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #dynamic-programming 

**Companies**

`Unknown`

You are given two integer arrays, `skill` and `mana`, of length `n` and `m`, respectively.

In a laboratory, `n` wizards must brew `m` potions _in order_. Each potion has a mana capacity `mana[j]` and **must** pass through **all** the wizards sequentially to be brewed properly. The time taken by the `ith` wizard on the `jth` potion is `timeij = skill[i] * mana[j]`.

Since the brewing process is delicate, a potion **must** be passed to the next wizard immediately after the current wizard completes their work. This means the timing must be _synchronized_ so that each wizard begins working on a potion **exactly** when it arrives. ​

Return the **minimum** amount of time required for the potions to be brewed properly.

**Example 1:**

**Input:** skill = [1,5,2,4], mana = [5,1,4,2]

**Output:** 110

**Explanation:**

|Potion Number|Start time|Wizard 0 done by|Wizard 1 done by|Wizard 2 done by|Wizard 3 done by|
|---|---|---|---|---|---|
|0|0|5|30|40|60|
|1|52|53|58|60|64|
|2|54|58|78|86|102|
|3|86|88|98|102|110|

As an example for why wizard 0 cannot start working on the 1st potion before time `t = 52`, consider the case where the wizards started preparing the 1st potion at time `t = 50`. At time `t = 58`, wizard 2 is done with the 1st potion, but wizard 3 will still be working on the 0th potion till time `t = 60`.

**Example 2:**

**Input:** skill = [1,1,1], mana = [1,1,1]

**Output:** 5

**Explanation:**

1. Preparation of the 0th potion begins at time `t = 0`, and is completed by time `t = 3`.
2. Preparation of the 1st potion begins at time `t = 1`, and is completed by time `t = 4`.
3. Preparation of the 2nd potion begins at time `t = 2`, and is completed by time `t = 5`.

**Example 3:**

**Input:** skill = [1,2,3,4], mana = [1,2]

**Output:** 21

**Constraints:**

- `n == skill.length`
- `m == mana.length`
- `1 <= n, m <= 5000`
- `1 <= mana[i], skill[i] <= 5000`

---

[Submissions](https://leetcode.com/problems/find-the-minimum-amount-of-time-to-brew-potions/submissions/?source=vscode "https://leetcode.com/problems/find-the-minimum-amount-of-time-to-brew-potions/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/find-the-minimum-amount-of-time-to-brew-potions/solutions/?source=vscode "https://leetcode.com/problems/find-the-minimum-amount-of-time-to-brew-potions/solutions/?source=vscode")

```python

class Solution:
    def minTime(self, skill: List[int], mana: List[int]) -> int:
        # n = number of skills (workers or tasks)
        # m = number of mana values (energy levels or operations)
        n, m = len(skill), len(mana)

        # times[i] represents the accumulated time after processing up to skill i
        times = [0] * n

        # Iterate over each mana value (each "round" or "phase")
        for j in range(m):
            cur_time = 0
            # Forward pass: compute total time if we apply mana[j] to all skills
            for i in range(n):
                # Each skill i takes (skill[i] * mana[j]) extra time
                # The start time for the current skill must be after all previous tasks are finished,
                # so we take max(cur_time, times[i]).
                cur_time = max(cur_time, times[i]) + skill[i] * mana[j]

            # After the forward pass, record the total time for the last skill
            times[n - 1] = cur_time

            # Backward pass: propagate adjusted completion times for earlier skills
            # (so that the "end time" chain is consistent with this round’s cost)
            for i in range(n - 2, -1, -1):
                # Each earlier skill finishes earlier by subtracting the last segment cost
                times[i] = times[i + 1] - skill[i + 1] * mana[j]

        # The last element stores the final minimum total time
        return times[n - 1]

```

#### Complexity Analysis

Let n be the length of skill and m be the length of mana.

- Time complexity: O(nm).
    
    The dynamic programming approach requires O(nm) time.
    
- Space complexity: O(n).
    
    We use a one-dimensional array to store intermediate results.