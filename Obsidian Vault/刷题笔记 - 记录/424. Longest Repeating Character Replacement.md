
| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (57.34%) | 12503 | 716      |

**Tags**

[`two-pointers`](https://leetcode.com/tag/two-pointers?source=vscode "https://leetcode.com/tag/two-pointers?source=vscode") | [`sliding-window`](https://leetcode.com/tag/sliding-window?source=vscode "https://leetcode.com/tag/sliding-window?source=vscode") #two-pointers #sliding-window 

**Companies**

`pocketgems`

You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**

```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achieve this answer too.
```

**Constraints:**

- `1 <= s.length <= 105`
- `s` consists of only uppercase English letters.
- `0 <= k <= s.length`

---

[Submissions](https://leetcode.com/problems/longest-repeating-character-replacement/submissions/?source=vscode "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/longest-repeating-character-replacement/solutions/?source=vscode "https://leetcode.com/problems/longest-repeating-character-replacement/solutions/?source=vscode")

```python

class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        start = 0
        freq_map = defaultdict(int)
        max_freq = 0
        longest_substring_length = 0
        for end in range(len(s)):
            freq_map[s[end]]+=1

            # the maximum frequency we have seen in any window yet
            max_freq = max(max_freq, freq_map[s[end]])

            # move the start pointer towards right if the current
            # window is invalid
            is_valid = (end + 1 - start - max_freq <= k)
            # Because we only expand the window by one character at a time, and max_freq never decreases, 
            # the quantity window_length - max_freq can increase by at most 1 on each step.
            # Since the previous window was valid (≤ k), the new one is either still valid, or exactly k + 1.
            # In the latter case, shrinking the window by moving start once reduces the length by 1 and makes the window valid again.
            # That’s why a single left shift in the if block is always sufficient—no while loop is needed.
            if not is_valid:
                freq_map[s[start]] -= 1
                start += 1

            # the window is valid at this point, store length
            # size of the window never decreases
            # since the window size only stay or grow, so we dont need max()
            longest_substring_length = end + 1 - start

        return longest_substring_length

```

O(n)
O(m)