


```python

from collections import defaultdict
from typing import List

class Solution:
    def countTrapezoids(self, points: List[List[int]]) -> int:
        n = len(points)
        inf = 10**9 + 7   # A special value to represent vertical line slope

        # slope_to_intercept[k] = list of intercepts (b) of lines with slope k.
        #   We will later group segments that lie on parallel but different lines.
        slope_to_intercept = defaultdict(list)

        # mid_to_slope[mid] = list of slopes of segments whose midpoint is "mid".
        #   We will later use this to count parallelograms via their diagonals.
        mid_to_slope = defaultdict(list)

        ans = 0

        # --------------------------------------------------
        # Step 1: Enumerate all segments defined by point pairs
        # --------------------------------------------------
        for i in range(n):
            x1, y1 = points[i]
            for j in range(i + 1, n):
                x2, y2 = points[j]
                dx = x1 - x2
                dy = y1 - y2

                # Handle vertical lines separately: x = const
                if x2 == x1:
                    # Use "inf" as a special slope for vertical lines
                    k = inf
                    # For vertical lines, instead of y = kx + b, we store x = b
                    b = x1
                else:
                    # Slope of the line passing through (x1, y1) and (x2, y2)
                    # Mathematically: k = (y2 - y1) / (x2 - x1) = dy / dx
                    k = (y2 - y1) / (x2 - x1)

                    # ⚠ Why do we compute b like this instead of b = y1 - k*x1 or y2 - k*x2?
                    #
                    # In exact math these are equivalent:
                    #   b = y1 - k*x1 = y1 - (dy/dx)*x1 = (y1*dx - x1*dy) / dx
                    #
                    # However, k is a floating-point value. For points A, B, C on the
                    # same line, the three segments AB, AC, BC use different (dx, dy),
                    # so k_AB, k_AC, k_BC can differ slightly due to rounding.
                    # If we then do b = y2 - k*x2, this tiny difference in k is
                    # amplified by x2 and subtraction, and we end up with slightly
                    # different b’s for segments that lie on the *same* geometric line.
                    #
                    # Since we later use (k, b) as keys to group segments that share
                    # a line, those tiny differences can split one line into several
                    # buckets and over-count trapezoids (this is exactly why changing
                    # to b = y2 - k*x2 caused Wrong Answer on large tests).
                    #
                    # Here we instead compute:
                    #   b = (y1*dx - x1*dy) / dx
                    # where dx, dy are the integer differences between the two points.
                    # For collinear points, another segment on the same line has
                    # dx' = λ*dx, dy' = λ*dy, so:
                    #   (y1*dx' - x1*dy') / dx' = (y1*dx - x1*dy) / dx
                    # i.e. we get *exactly the same rational value* for b before the
                    # final float division. This greatly reduces the chance that
                    # segments on the same line get different b’s due to float noise.
                    b = (y1 * dx - x1 * dy) / dx

                # Encode the midpoint of the segment as an integer key:
                # midpoint = ((x1+x2)/2, (y1+y2)/2)
                # We avoid floats by packing (x1+x2, y1+y2) into a single integer.
                # 10000 is just a large enough base to separate x and y parts safely.
                mid = (x1 + x2) * 10000 + (y1 + y2)

                # Group lines by slope → collect their intercepts
                slope_to_intercept[k].append(b)
                # Group segments by midpoint → collect their slopes
                mid_to_slope[mid].append(k)

        # --------------------------------------------------
        # Step 2: Count pairs of parallel, non-collinear segments
        #         (lines with the same slope but different intercepts).
        #
        # For a fixed slope k:
        #   - Each distinct intercept b corresponds to a distinct line.
        #   - If a line has count c_b segments on it, we have c_b ways to choose a side
        #     from this line.
        # For all lines with this slope k (b1, b2, ...):
        #   total number of ways to choose segments on two different parallel lines is
        #       sum_{i < j} (c_bi * c_bj)
        # Each such pair of segments can potentially be one pair of parallel sides
        # of a trapezoid-like quadrilateral (including parallelograms).
        # --------------------------------------------------
        for sti in slope_to_intercept.values():
            # Only one segment → cannot form a pair
            if len(sti) == 1:
                continue

            # Count how many segments lie on each distinct line (intercept b)
            cnt = defaultdict(int)
            for b_val in sti:
                cnt[b_val] += 1

            # Compute sum_{i < j} c_i * c_j using prefix sums
            total_sum = 0
            for count in cnt.values():
                # For current count, it can pair with all previous segments counted so far
                ans += total_sum * count
                total_sum += count

        # --------------------------------------------------
        # Step 3: Subtract over-counted parallelograms.
        #
        # A parallelogram has two pairs of parallel sides, so it was counted twice
        # in the step above (once for each direction of parallel sides).
        #
        # However, a key geometric property:
        #   - The diagonals of a parallelogram share the same midpoint.
        #   - Those diagonals are not parallel (their slopes differ).
        #
        # So, if we fix a midpoint "mid":
        #   - All segments that share this midpoint are potential diagonals.
        #   - Among them, pairs of segments with different slopes correspond
        #     to actual parallelograms.
        #
        # Thus, for each midpoint, if we group segments by slope:
        #   let c_k be the count of segments with slope k.
        #   Then the number of ways to pick two non-parallel segments is:
        #       sum_{k1 < k2} c_k1 * c_k2
        #
        # Each such pair represents one parallelogram whose diagonals share
        # this midpoint. These parallelograms were counted twice earlier,
        # so we subtract them once.
        # --------------------------------------------------
        for mts in mid_to_slope.values():
            # Only one segment → cannot form a pair of diagonals
            if len(mts) == 1:
                continue

            # Count how many segments with each slope share this midpoint
            cnt = defaultdict(int)
            for k_val in mts:
                cnt[k_val] += 1

            # Again compute sum_{i < j} c_i * c_j, where each slope is a group
            total_sum = 0
            for count in cnt.values():
                ans -= total_sum * count  # subtract over-counted parallelograms
                total_sum += count

        # After:
        #   - Adding all pairs of parallel, non-collinear segments (potential trapezoids)
        #   - Subtracting all parallelograms once (because they were counted twice)
        # we end up with the number of distinct quadrilaterals that have at least
        # one pair of parallel sides (generalized trapezoids).
        return ans

```
O(n^2)
O(n^2)