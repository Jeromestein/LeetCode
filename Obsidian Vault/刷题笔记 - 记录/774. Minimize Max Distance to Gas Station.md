
| Category   | Difficulty     | Likes | Dislikes |
| ---------- | -------------- | ----- | -------- |
| algorithms | #Hard (52.97%) | 700   | 102      |

**Tags**

[`tree`](https://leetcode.com/tag/tree?source=vscode "https://leetcode.com/tag/tree?source=vscode") | [`depth-first-search`](https://leetcode.com/tag/depth-first-search?source=vscode "https://leetcode.com/tag/depth-first-search?source=vscode") | [`breadth-first-search`](https://leetcode.com/tag/breadth-first-search?source=vscode "https://leetcode.com/tag/breadth-first-search?source=vscode") #binary-search 

**Companies**

`Unknown`

You are given an integer array `stations` that represents the positions of the gas stations on the **x-axis**. You are also given an integer `k`.

You should add `k` new gas stations. You can add the stations anywhere on the **x-axis**, and not necessarily on an integer position.

Let `penalty()` be the maximum distance between **adjacent** gas stations after adding the `k` new stations.

Return _the smallest possible value of_ `penalty()`. Answers within `10-6` of the actual answer will be accepted.

**Example 1:**

```
Input: stations = [1,2,3,4,5,6,7,8,9,10], k = 9
Output: 0.50000
```

**Example 2:**

```
Input: stations = [23,24,36,39,46,56,57,65,84,98], k = 1
Output: 14.00000
```

**Constraints:**

- `10 <= stations.length <= 2000`
- `0 <= stations[i] <= 108`
- `stations` is sorted in a **strictly increasing** order.
- `1 <= k <= 106`

---

[Submissions](https://leetcode.com/problems/minimize-max-distance-to-gas-station/submissions/?source=vscode "https://leetcode.com/problems/minimize-max-distance-to-gas-station/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/minimize-max-distance-to-gas-station/solutions/?source=vscode "https://leetcode.com/problems/minimize-max-distance-to-gas-station/solutions/?source=vscode")


```python

class Solution(object):
    def minmaxGasDist(self, stations, K):
        # Helper function:
        # Return True if we can ensure that the maximum distance
        # between adjacent stations is <= D
        # by adding at most K new stations.
        def possible(D):
            # For each segment between two existing stations,
            # calculate how many additional stations are needed
            # to make every sub-distance <= D
            return sum(int((stations[i + 1] - stations[i]) / D)
                       for i in range(len(stations) - 1)) <= K

        # Binary search range:
        # lo = minimum possible distance (0)
        # hi = maximum possible distance (large enough upper bound)
        lo, hi = 0, 10**8

        # Continue binary search until the precision threshold is small enough
        while hi - lo > 1e-6:
            mi = (lo + hi) / 2.0  # mid = current guess for max distance

            # If it's possible to achieve max gap ≤ mi with ≤ K stations,
            # try smaller D (narrow the upper bound)
            if possible(mi):
                hi = mi
            else:
                # Otherwise, need a larger D (not enough K stations)
                lo = mi

        # The minimal possible max distance is approximately lo (or hi)
        return lo

```

**Complexity Analysis**

- Time Complexity: O(NlogW), where N is the length of `stations`, and W=1014 is the range of possible answers (108), divided by the acceptable level of precision (10−6).
    
- Space Complexity: O(1) in additional space complexity.