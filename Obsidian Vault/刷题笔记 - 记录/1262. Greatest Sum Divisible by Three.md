| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (50.94%) | 2344  | 62       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #array #greedy #dynamic-programming #sorting 

**Companies**

`Unknown`

Given an integer array `nums`, return _the **maximum possible sum** of elements of the array such that it is divisible by three_.

**Example 1:**

```
Input: nums = [3,6,5,1,8]
Output: 18
Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).
```

**Example 2:**

```
Input: nums = [4]
Output: 0
Explanation: Since 4 is not divisible by 3, do not pick any number.
```

**Example 3:**

```
Input: nums = [1,2,3,4,4]
Output: 12
Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).
```

**Constraints:**

- `1 <= nums.length <= 4 * 104`
- `1 <= nums[i] <= 104`

---

[Submissions](https://leetcode.com/problems/greatest-sum-divisible-by-three/submissions/?source=vscode "https://leetcode.com/problems/greatest-sum-divisible-by-three/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/greatest-sum-divisible-by-three/solutions/?source=vscode "https://leetcode.com/problems/greatest-sum-divisible-by-three/solutions/?source=vscode")

```python

class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:

        # Group nums based on remainder mod 3
        a = [x for x in nums if x % 3 == 0]               # remainder 0
        b = sorted([x for x in nums if x % 3 == 1], reverse=True)  # remainder 1, sorted descending
        c = sorted([x for x in nums if x % 3 == 2], reverse=True)  # remainder 2, sorted descending

        ans = 0
        lb, lc = len(b), len(c)

        # Try possible counts of elements from B and C.
        # Only need to try {len, len-1, len-2} for each.
        for cntB in [lb - 2, lb - 1, lb]:
            if cntB >= 0:
                for cntC in [lc - 2, lc - 1, lc]:
                    if cntC >= 0 and (cntB - cntC) % 3 == 0:
                        # If counts satisfy mod rule, compute the maximum sum
                        ans = max(ans, sum(b[:cntB]) + sum(c[:cntC]))

        # Add all elements with remainder 0 (since they always fit)
        return ans + sum(a)

```

O(nlogn)
O(n)

# DP ????
```python

class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        f = [0, -float("inf"), -float("inf")]
        for num in nums:
            g = f[:]
            for i in range(3):
                g[(i + num % 3) % 3] = max(g[(i + num % 3) % 3], f[i] + num)
            f = g
        return f[0]

```
O(n)
O(1)