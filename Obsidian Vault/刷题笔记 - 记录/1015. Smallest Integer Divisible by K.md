| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (46.58%) | 1481  | 1097     |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #math #divide 

**Companies**

`Unknown`

Given a positive integer `k`, you need to find the **length** of the **smallest** positive integer `n` such that `n` is divisible by `k`, and `n` only contains the digit `1`.

Return _the **length** of_ `n`. If there is no such `n`, return -1.

**Note:** `n` may not fit in a 64-bit signed integer.

**Example 1:**

```
Input: k = 1
Output: 1
Explanation: The smallest answer is n = 1, which has length 1.
```

**Example 2:**

```
Input: k = 2
Output: -1
Explanation: There is no such positive integer n divisible by 2.
```

**Example 3:**

```
Input: k = 3
Output: 3
Explanation: The smallest answer is n = 111, which has length 3.
```

**Constraints:**

- `1 <= k <= 105`

---

[Submissions](https://leetcode.com/problems/smallest-integer-divisible-by-k/submissions/?source=vscode "https://leetcode.com/problems/smallest-integer-divisible-by-k/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/smallest-integer-divisible-by-k/solutions/?source=vscode "https://leetcode.com/problems/smallest-integer-divisible-by-k/solutions/?source=vscode")

```python

class Solution:
    def smallestRepunitDivByK(self, k: int) -> int:
        # remainder will store the remainder of the current repunit number mod k.
        # A "repunit" is a number like 1, 11, 111, 1111, ...
        # Instead of constructing the huge number directly,
        # we only track its remainder modulo k.
        remainder = 0

        # We try at most k repunit lengths.
        # Why? Because there are only k possible remainders: 0, 1, 2, ..., k-1.
        # By the Pigeonhole Principle, if we have not seen remainder = 0
        # after k steps, then some remainder must have repeated,
        # meaning we are in a cycle that will never reach 0.
        # This guarantees either:
        #   - we find the answer within k steps, OR
        #   - no solution exists.
        for length in range(1, k + 1):

            # Build the next remainder using the recurrence:
            #
            #   R_{n+1} = (R_n * 10 + 1) % k
            #
            # This corresponds to the number:
            #   1 → 11 → 111 → 1111 → ...
            #
            # Why is this correct mathematically?
            #
            # Because modulo arithmetic allows "congruence substitution":
            #
            #   (N % k) and N are interchangeable in expressions involving +, -, ×.
            #
            # Key identities:
            #   (A + B) % k = (A % k + B % k) % k
            #   (A * B) % k = (A % k * B % k) % k
            #
            # So instead of computing:
            #   new_number = old_number * 10 + 1   (which becomes enormous)
            #
            # We compute only:
            #   remainder = (remainder * 10 + 1) % k
            #
            # And the remainder is guaranteed to be the same as
            # the huge repunit number % k.
            remainder = (remainder * 10 + 1) % k

            # If the remainder hits 0, the current repunit (length digits of '1')
            # is divisible by k. We immediately return its length.
            if remainder == 0:
                return length

        # If we tried all k possible remainders without finding 0,
        # it means no repunit divisible by k exists.
        # This happens exactly when gcd(k, 10) != 1 (i.e., k divisible by 2 or 5).
        return -1

```
O(k)
O(1)