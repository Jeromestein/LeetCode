

```python

class DSU:
    def __init__(self, size):
        # Initialize the parent list so that each node is its own parent.
        self.parent = list(range(size))

    def find(self, x):
        # Standard DSU 'find' with path compression.
        # If x is not its own parent, recursively find its root,
        # and update parent[x] to point directly to the root for efficiency.
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def join(self, u, v):
        # Union operation: connect the sets containing u and v.
        # The root of v’s set is assigned to the root of u’s set.
        self.parent[self.find(v)] = self.find(u)


class Solution:
    def processQueries(
        self, c: int, connections: List[List[int]], queries: List[List[int]]
    ) -> List[int]:
        # Initialize DSU with c + 1 (1-based indexing of stations)
        dsu = DSU(c + 1)

        # Build static connectivity between stations
        # Each connection joins two stations into one component
        for p in connections:
            dsu.join(p[0], p[1])

        # Track current online/offline status of each station
        online = [True] * (c + 1)
        # Count how many times a station goes offline (some may repeat)
        offline_counts = [0] * (c + 1)
        # Map: component root -> smallest currently online station ID
        minimum_online_stations = {}

        # --- Step 1: Pretend all "offline" operations have already been executed ---
        # We mark which stations will end up offline after processing all queries.
        for q in queries:
            op, x = q[0], q[1]
            if op == 2:  # station x goes offline
                online[x] = False
                offline_counts[x] += 1

        # --- Step 2: For each connected component, find the smallest online station ---
        for i in range(1, c + 1):
            root = dsu.find(i)
            # If this component hasn’t been seen before, initialize its min value as -1.
            if root not in minimum_online_stations:
                minimum_online_stations[root] = -1

            station = minimum_online_stations[root]
            # Update the minimum online station if station i is online and smaller.
            if online[i]:
                if station == -1 or station > i:
                    minimum_online_stations[root] = i

        ans = []

        # --- Step 3: Process the queries in reverse order ---
        # Because forward simulation would require dynamic deletions,
        # we reverse the timeline: "offline" becomes "online" restoration.
        for i in range(len(queries) - 1, -1, -1):
            op, x = queries[i][0], queries[i][1]
            root = dsu.find(x)
            station = minimum_online_stations[root]

            if op == 1:
                # Query: which station handles maintenance for x?
                if online[x]:
                    # If x itself is online, it handles the request.
                    ans.append(x)
                else:
                    # Otherwise, use the smallest online station in its component (or -1 if none)
                    ans.append(station)

            if op == 2:
                # Reverse of "station x goes offline" → now "x comes online"
                if offline_counts[x] > 1:
                    # If x had multiple offline events, only decrement the counter now.
                    offline_counts[x] -= 1
                else:
                    # Fully restore x to online
                    online[x] = True
                    # Update the component's minimum online station if needed
                    if station == -1 or station > x:
                        minimum_online_stations[root] = x

        # --- Step 4: The result list was built in reverse, so reverse it back ---
        return ans[::-1]
```

#### Complexity Analysis

Let m be the length of connections, i.e., the number of edges in the graph; q be the length of queries; and α be the inverse Ackermann function.

- Time complexity: O((m+c+q)×α(c)).
    
    Assuming the disjoint set union implementation uses path compression, computing the connected components takes O(m×α(c)), preprocessing the minimum number of online sites for each connected component takes O(c×α(c)), and finally traversing the queries in reverse to compute the answers takes O(q×α(c)).
    
- Space complexity: O(c).
    
    Union-Find, online, offlineCounts and minimumOnlineStations all require O(c) space.