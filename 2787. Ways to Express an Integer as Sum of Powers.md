
| Category   | Difficulty       | Likes | Dislikes |
| ---------- | ---------------- | ----- | -------- |
| algorithms | #Medium (33.88%) | 687   | 29       |

**Tags**

[`Unknown`](https://leetcode.com/tag/Unknown?source=vscode "https://leetcode.com/tag/Unknown?source=vscode") #dynamic-programming 

**Companies**

`Unknown`

Given two **positive** integers `n` and `x`.

Return _the number of ways_ `n` _can be expressed as the sum of the_ `xth` _power of **unique** positive integers, in other words, the number of sets of unique integers_ `[n1, n2, ..., nk]` _where_ `n = n1x + n2x + ... + nkx`_._

Since the result can be very large, return it modulo `109 + 7`.

For example, if `n = 160` and `x = 3`, one way to express `n` is `n = 23 + 33 + 53`.

**Example 1:**

```
Input: n = 10, x = 2
Output: 1
Explanation: We can express n as the following: n = 32 + 12 = 10.
It can be shown that it is the only way to express 10 as the sum of the 2nd power of unique integers.
```

**Example 2:**

```
Input: n = 4, x = 1
Output: 2
Explanation: We can express n in the following ways:
- n = 41 = 4.
- n = 31 + 11 = 4.
```

**Constraints:**

- `1 <= n <= 300`
- `1 <= x <= 5`

---

[Submissions](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/submissions/?source=vscode "https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/submissions/?source=vscode") | [Solution](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/solutions/?source=vscode "https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/solutions/?source=vscode")



```python

class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        """
        Count the number of sets of distinct positive integers {a1, a2, ..., ak}
        such that a1**x + a2**x + ... + ak**x = n.
        This is a 0/1 knapsack counting DP over items {1**x, 2**x, ..., t**x},
        where t = floor(n**(1/x)). Each power can be used at most once.
        """
        MOD = 10**9 + 7

        # dp[s] = number of ways to form sum s using the powers processed so far
        dp = [0] * (n + 1)
        dp[0] = 1  # one way to form sum 0: choose the empty set

        # Iterate over items (powers) in increasing base i
        for i in range(1, n + 1):
            val = i ** x  # the "weight/value" of this item (i^x)
            if val > n:
                break  # all further powers will also exceed n

            # 0/1 knapsack update in decreasing order to avoid reusing the same item
            for s in range(n, val - 1, -1):
                # add ways that include this item: form (s - val) previously, then add val
                dp[s] = (dp[s] + dp[s - val]) % MOD

        # Number of ways to form sum n
        return dp[n]

```